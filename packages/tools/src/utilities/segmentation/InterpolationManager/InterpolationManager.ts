import {
  getEnabledElements,
  utilities as csUtils,
  getRenderingEngine,
} from '@cornerstonejs/core';
import type { Types } from '@cornerstonejs/core';
import {
  AnnotationCompletedEventType,
  AnnotationModifiedEventType,
  AnnotationRemovedEventType,
} from '../../../types/EventTypes';
import getInterpolationDataCollection from '../../contours/interpolation/getInterpolationDataCollection';
import type { InterpolationViewportData } from '../../../types/InterpolationTypes';
import interpolate from '../../contours/interpolation/interpolate';
import updateRelatedAnnotations from './updateRelatedAnnotations';
import deleteRelatedAnnotations from './deleteRelatedAnnotations';
import { InterpolationROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';
import ChangeTypes from '../../../enums/ChangeTypes';

const { uuidv4, isEqual } = csUtils;

function getSliceData(viewport): Types.ImageSliceData {
  const sliceData: Types.ImageSliceData = {
    numberOfSlices: viewport.getNumberOfSlices(),
    imageIndex: viewport.getCurrentImageIdIndex(),
  };
  return sliceData;
}

function getMatchingViewport(annotation: InterpolationROIAnnotation) {
  const { metadata } = annotation;
  const enabledElement = getEnabledElements().find((enabledElement) => {
    if (enabledElement.FrameOfReferenceUID === metadata.FrameOfReferenceUID) {
      const viewport = enabledElement.viewport;
      const { viewPlaneNormal, viewUp } = viewport.getCamera();
      return (
        isEqual(viewPlaneNormal, metadata.viewPlaneNormal) &&
        isEqual(viewUp, metadata.viewUp)
      );
    }
    return;
  });
  return enabledElement?.viewport;
}

export default class InterpolationManager {
  static toolNames = [];

  static addTool(toolName: string) {
    if (-1 === this.toolNames.indexOf(toolName)) {
      this.toolNames.push(toolName);
    }
  }

  static handleAnnotationCompleted = (evt: AnnotationCompletedEventType) => {
    const { renderingEngineId, viewportId } = evt.detail;
    const annotation = evt.detail.annotation as InterpolationROIAnnotation;
    if (!annotation?.metadata) {
      return;
    }
    const { toolName } = annotation.metadata;

    if (-1 === this.toolNames.indexOf(toolName)) {
      return;
    }

    const renderingEngine = getRenderingEngine(renderingEngineId);
    const viewport = renderingEngine.getViewport(viewportId);
    const sliceData: Types.ImageSliceData = getSliceData(viewport);
    const viewportData: InterpolationViewportData = {
      viewport,
      sliceData,
      annotation,
      interpolationUID: annotation.interpolationUID,
    };
    const isInitializeLabel = !annotation.interpolationUID;
    // If any update, triggered on an annotation, then it will be treated as non-autogenerated.
    annotation.autoGenerated = false;
    if (!isInitializeLabel) {
      updateRelatedAnnotations(viewportData, true);
    }
    if (!annotation.interpolationUID) {
      const filterData = [
        {
          key: 'segmentIndex',
          value: annotation.data.segmentation.segmentIndex,
          parentKey: (annotation) => annotation.data.segmentation,
        },
        {
          key: 'viewPlaneNormal',
          value: annotation.metadata.viewPlaneNormal,
          parentKey: (annotation) => annotation.metadata,
        },
        {
          key: 'viewUp',
          value: annotation.metadata.viewUp,
          parentKey: (annotation) => annotation.metadata,
        },
      ];
      let interpolationAnnotations = getInterpolationDataCollection(
        viewportData,
        filterData,
        true
      );
      // Skip other type of annotations with same location
      interpolationAnnotations = interpolationAnnotations.filter(
        (interpolationAnnotation) => interpolationAnnotation.interpolationUID
      );
      if (!annotation.interpolationUID) {
        annotation.interpolationUID =
          interpolationAnnotations[0]?.interpolationUID || uuidv4();
        viewportData.interpolationUID = annotation.interpolationUID;
      }
      interpolate(viewportData);
    }
  };

  static handleAnnotationUpdate = (evt: AnnotationModifiedEventType) => {
    const { renderingEngineId, viewportId, changeType } = evt.detail;
    const annotation = evt.detail.annotation as InterpolationROIAnnotation;
    if (!annotation?.metadata) {
      return;
    }
    const { toolName } = annotation.metadata;

    if (
      -1 === this.toolNames.indexOf(toolName) ||
      changeType === ChangeTypes.StatsUpdated
    ) {
      return;
    }

    const renderingEngine = getRenderingEngine(renderingEngineId);
    const viewport = renderingEngine.getViewport(viewportId);
    const sliceData: Types.ImageSliceData = getSliceData(viewport);
    const viewportData: InterpolationViewportData = {
      viewport,
      sliceData,
      annotation,
      interpolationUID: annotation.interpolationUID,
    };
    updateRelatedAnnotations(viewportData, false);
  };

  static handleAnnotationDelete = (evt: AnnotationRemovedEventType) => {
    const annotation = evt.detail.annotation as InterpolationROIAnnotation;
    if (!annotation?.metadata) {
      return;
    }
    const { toolName } = annotation.metadata;

    if (-1 === this.toolNames.indexOf(toolName) || annotation.autoGenerated) {
      return;
    }
    const viewport = getMatchingViewport(annotation);

    if (!viewport) {
      console.log("No viewport, can't delete");
      return;
    }

    const sliceData: Types.ImageSliceData = getSliceData(viewport);
    const viewportData: InterpolationViewportData = {
      viewport,
      sliceData,
      annotation,
      interpolationUID: annotation.interpolationUID,
    };
    // If any update, triggered on an annotation, then it will be treated as non-interpolated.
    annotation.autoGenerated = false;
    deleteRelatedAnnotations(viewportData);
  };
}
