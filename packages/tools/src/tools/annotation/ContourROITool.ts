import {
  getEnabledElement,
  Types,
  utilities as csUtils,
  StackViewport,
  VolumeViewport,
} from '@cornerstonejs/core';
import registerContourDrawLoop from './contourROITool/drawLoop';
import { EventTypes, PublicToolProps, ToolProps } from '../../types';
import PlanarFreehandROITool from './PlanarFreehandROITool';
import { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';
import triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';
import InterpolationManager from '../../utilities/contourROITool/InterpolationManager';
import { InterpolationROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';
import * as annotation from '../../stateManagement/annotation';

const { getImageSliceDataForVolumeViewport } = csUtils;

class ContourROITool extends PlanarFreehandROITool {
  constructor(toolProps: PublicToolProps = {}, defaultToolProps: ToolProps) {
    super(toolProps, defaultToolProps);
    this.configuration.allowOpenContours = false;
    this.configuration.interpolation.interpolateOnAdd = false;
    this.configuration.interpolation.interpolateOnEdit = false;
    this.configuration.makeClockWise = true;
    InterpolationManager.addTool(ContourROITool.toolName);

    // Register event loops and rendering logic, which are stored in different
    // Files due to their complexity/size.
    registerContourDrawLoop(this);
  }

  getSliceData(viewport, referencedImageId): Types.ImageSliceData {
    let sliceData: Types.ImageSliceData = { numberOfSlices: 0, imageIndex: 0 };
    if (viewport instanceof VolumeViewport) {
      sliceData = getImageSliceDataForVolumeViewport(viewport);
    } else if (viewport instanceof StackViewport) {
      const imageIds = viewport.getImageIds();
      sliceData.numberOfSlices = imageIds.length;
      sliceData.imageIndex = imageIds.findIndex((x) => x === referencedImageId);
    }
    return sliceData;
  }

  /**
   * Based on the current position of the mouse and the current image, creates
   * a `InterpolationROIAnnotation` and stores it in the annotationManager.
   *
   * @param evt - `EventTypes.NormalizedMouseEventType`
   * @returns The `InterpolationROIAnnotation` object.
   */
  addNewAnnotation = (
    evt: EventTypes.InteractionEventType
  ): InterpolationROIAnnotation => {
    const eventDetail = evt.detail;
    const { currentPoints, element } = eventDetail;
    const worldPos = currentPoints.world;
    const enabledElement = getEnabledElement(element);
    const { viewport, renderingEngine } = enabledElement;
    const camera = viewport.getCamera();
    const { viewPlaneNormal, viewUp } = camera;
    const referencedImageId = this.getReferencedImageId(
      viewport,
      worldPos,
      viewPlaneNormal,
      viewUp
    );

    const viewportIdsToRender = getViewportIdsWithToolToRender(
      element,
      this.getToolName()
    );

    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
    const sliceData: Types.ImageSliceData = this.getSliceData(
      viewport,
      referencedImageId
    );

    const annotationData: InterpolationROIAnnotation = {
      highlighted: true,
      invalidated: true,
      metadata: {
        viewPlaneNormal: [...viewPlaneNormal] as Types.Point3,
        viewUp: [...viewUp] as Types.Point3,
        FrameOfReferenceUID,
        referencedImageId,
        referencedSliceIndex: sliceData.imageIndex,
        toolName: this.getToolName(),
      },
      data: {
        handles: {
          points: [], // Handle points for open contours
          activeHandleIndex: null,
          textBox: {
            hasMoved: false,
            worldPosition: [0, 0, 0],
            worldBoundingBox: {
              topLeft: [0, 0, 0] as Types.Point3,
              topRight: [0, 0, 0] as Types.Point3,
              bottomLeft: [0, 0, 0] as Types.Point3,
              bottomRight: [0, 0, 0] as Types.Point3,
            },
          },
        },
        polyline: [[...worldPos] as Types.Point3], // Polyline coordinates
        label: '',
        cachedStats: {},
      },
      interpolationUID: '',
      autoGenerated: false,
    };

    annotation.state.addAnnotation(annotationData, element);
    this.activateDraw(evt, annotationData, viewportIdsToRender);
    evt.preventDefault();
    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);

    return annotationData;
  };
}

ContourROITool.toolName = 'ContourROI';
export default ContourROITool;
