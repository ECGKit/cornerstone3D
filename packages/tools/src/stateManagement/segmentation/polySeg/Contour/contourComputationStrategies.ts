import { cache, utilities as csUtils } from '@cornerstonejs/core';
import type { Types } from '@cornerstonejs/core';
import { getUniqueSegmentIndices } from '../../../../utilities/segmentation';
import { getSegmentation } from '../../segmentationState';
import { PolySegConversionOptions } from '../../../../types';
import { addAnnotation } from '../../..';
import { triggerAnnotationRenderForViewportIds } from '../../../../utilities';
import { computeSurfaceFromLabelmapSegmentation } from '../Surface/surfaceComputationStrategies';
import { clipAndCacheSurfacesForViewport } from '../../helpers/clipAndCacheSurfacesForViewport';

// the map between segment index and the intersection points and lines
export type RawContourData = Map<
  number,
  { points: number[]; lines: number[] }[]
>;

export async function computeContourData(
  segmentationId: string,
  options: PolySegConversionOptions = {}
) {
  const segmentIndices = options.segmentIndices?.length
    ? options.segmentIndices
    : getUniqueSegmentIndices(segmentationId);

  let rawContourData: RawContourData;
  const segmentation = getSegmentation(segmentationId);
  const representationData = segmentation.representationData;

  try {
    if (representationData.SURFACE) {
      rawContourData = await computeContourFromSurfaceSegmentation(
        segmentationId,
        {
          segmentIndices,
          ...options,
        }
      );
    } else if (representationData.LABELMAP) {
      rawContourData = await computeContourFromLabelmapSegmentation(
        segmentationId,
        {
          segmentIndices,
          ...options,
        }
      );
    }
  } catch (error) {
    console.error(error);
    throw error;
  }

  if (!rawContourData) {
    throw new Error(
      'Not enough data to convert to contour, currently only support converting volume labelmap to contour if available'
    );
  }

  const { viewport } = options;

  const finalResult = new Map<number, Set<string>>();
  // create the new annotations and add them to the segmentation state representation
  // data for the contour representation
  for (const [segmentIndex, contoursData] of rawContourData) {
    for (const contourData of contoursData) {
      const { numberOfCells, points, lines } = contourData;
      const firstLineNumberOfPoints = lines[0];
      const linesNumberOfPoints = [firstLineNumberOfPoints];
      const lineSegments = [];
      lineSegments.push(lines.slice(1, firstLineNumberOfPoints + 1));

      if (numberOfCells > 1) {
        let restOfLines = lines.slice(firstLineNumberOfPoints + 1);
        while (restOfLines[0] > 0) {
          linesNumberOfPoints.push(restOfLines[0]);
          lineSegments.push(restOfLines.slice(1, restOfLines[0] + 1));
          restOfLines = restOfLines.slice(restOfLines[0] + 1);
        }
      }
      // lineSegments.pop();

      for (let i = 0; i < 1; i++) {
        const line = lineSegments[i];
        const polyline = [];

        for (let j = 0; j < linesNumberOfPoints[i]; j++) {
          const pointIndex = line[j];
          polyline.push([
            points[3 * pointIndex],
            points[3 * pointIndex + 1],
            points[3 * pointIndex + 2],
          ]);
        }

        if (polyline.length < 3) {
          continue;
        }

        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();
        const camera = viewport.getCamera();
        const contourSegmentationAnnotation = {
          annotationUID: csUtils.uuidv4(),
          data: {
            contour: {
              closed: true,
              polyline,
            },
            segmentation: {
              segmentationId,
              segmentIndex,
            },
            handles: {},
          },
          handles: {},
          highlighted: false,
          autoGenerated: false,
          invalidated: false,
          isLocked: false,
          isVisible: true,
          metadata: {
            referencedImageId: viewport.getCurrentImageId?.(),
            toolName: 'PlanarFreehandContourSegmentationTool',
            FrameOfReferenceUID: FrameOfReferenceUID,
            viewPlaneNormal: camera.viewPlaneNormal,
          },
        };

        const annotationGroupSelector = viewport.element;

        addAnnotation(contourSegmentationAnnotation, annotationGroupSelector);

        const currentSet = finalResult.get(segmentIndex);
        if (!currentSet) {
          finalResult.set(
            segmentIndex,
            new Set([contourSegmentationAnnotation.annotationUID])
          );
        } else {
          currentSet.add(contourSegmentationAnnotation.annotationUID);
        }
      }
    }
  }

  triggerAnnotationRenderForViewportIds(viewport.getRenderingEngine(), [
    viewport.id,
  ]);

  return {
    annotationUIDsMap: finalResult,
  };
}

async function computeContourFromLabelmapSegmentation(
  segmentationId,
  options: PolySegConversionOptions = {}
) {
  const results = await computeSurfaceFromLabelmapSegmentation(
    segmentationId,
    options
  );

  if (!results?.length) {
    console.error('Failed to convert labelmap to surface or labelmap is empty');
    return;
  }

  const { viewport, segmentationRepresentationUID } = options;

  const pointsAndPolys = results.map((surface) => {
    return {
      id: surface.segmentIndex.toString(),
      points: surface.data.points,
      polys: surface.data.polys,
      segmentIndex: surface.segmentIndex,
    };
  });

  const polyDataCache = await clipAndCacheSurfacesForViewport(
    pointsAndPolys,
    viewport as Types.IVolumeViewport,
    segmentationRepresentationUID
  );

  const rawResults = new Map() as RawContourData;

  for (const [cacheId, intersectionInfo] of polyDataCache) {
    // Todo; fix this
    const surfaceId = cacheId.split('_')[1];

    for (const [_, result] of intersectionInfo) {
      if (!result) {
        continue;
      }
      const segmentIndex = Number(surfaceId);

      if (!segmentIndex) {
        continue;
      }

      if (!rawResults.has(segmentIndex)) {
        rawResults.set(segmentIndex, []);
      }

      rawResults.get(segmentIndex).push(result);
    }
  }

  return rawResults;
}

async function computeContourFromSurfaceSegmentation(
  segmentationId,
  options: PolySegConversionOptions = {}
): Promise<RawContourData> {
  const segmentIndices = options.segmentIndices?.length
    ? options.segmentIndices
    : getUniqueSegmentIndices(segmentationId);

  const segmentation = getSegmentation(segmentationId);

  const segmentIndexToSurfaceId = new Map() as Map<number, string>;
  const surfacesInfo = [];
  const representationData = segmentation.representationData.SURFACE;
  representationData.geometryIds.forEach((geometryId, segmentIndex) => {
    if (segmentIndices.includes(segmentIndex)) {
      segmentIndexToSurfaceId.set(segmentIndex, geometryId);
      const surface = cache.getGeometry(geometryId)?.data as Types.ISurface;
      if (surface) {
        surfacesInfo.push({
          id: geometryId,
          points: surface.getPoints(),
          polys: surface.getPolys(),
        });
      }
    }
  });

  // create a reverse map for the surface id to segment index
  const surfaceIdToSegmentIndex = new Map() as Map<string, number>;
  segmentIndexToSurfaceId.forEach((surfaceId, segmentIndex) => {
    surfaceIdToSegmentIndex.set(surfaceId, segmentIndex);
  });

  if (!options.viewport) {
    throw new Error('Viewport is required to compute contour from surface');
  }
  const { viewport, segmentationRepresentationUID } = options;

  const polyDataCache = await clipAndCacheSurfacesForViewport(
    surfacesInfo,
    viewport as Types.IVolumeViewport,
    segmentationRepresentationUID
  );

  const rawResults = new Map() as RawContourData;

  for (const [cacheId, intersectionInfo] of polyDataCache) {
    // Todo; fix this
    const surfaceId = cacheId.split('_')[1];

    for (const [_, result] of intersectionInfo) {
      if (!result) {
        continue;
      }

      const segmentIndex = surfaceIdToSegmentIndex.get(surfaceId);

      if (!segmentIndex) {
        continue;
      }

      if (!rawResults.has(segmentIndex)) {
        rawResults.set(segmentIndex, []);
      }

      rawResults.get(segmentIndex).push({ ...result, segmentIndex });
    }
  }

  return rawResults;
}

export { computeContourFromLabelmapSegmentation };
